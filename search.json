[
  {
    "objectID": "homework.html",
    "href": "homework.html",
    "title": "",
    "section": "",
    "text": "Linear algebra basics\n\n[10 points] Prove that the matrix xy^T has rank equals to one.\n[20 points] Find SVD of the following matrices:\n\nA = \\begin{bmatrix} 1\\\\2\\\\3 \\end{bmatrix}\nA = \\begin{bmatrix} 1 & 4\\\\4 & 8\\\\3 & 8 \\end{bmatrix}\nA = \\begin{bmatrix} 0 & 0\\\\x & 0\\\\0 & 0 \\end{bmatrix}, where x is the sum of your birthdate numbers (day + month)\n\n[10 points] Assume we have a set of data points x^{(i)}\\in\\mathbb{R}^{n},\\,i=1,\\dots,m, and decide to represent this data as a matrix\n\nX =\n     \\begin{pmatrix}\n     | & & | \\\\\n     x^{(1)} & \\dots & x^{(m)} \\\\\n     | & & | \\\\\n     \\end{pmatrix} \\in \\mathbb{R}^{n \\times m}.\n\nWe suppose that \\text{rank}\\,X = r.\nIn the problem below, we ask you to find the rank of some matrix M related to X. In particular, you need to find relation between \\text{rank}\\,X = r and \\text{rank}\\,M, e.g., that the rank of M is always larger/smaller than the rank of X or that \\text{rank}\\,M = \\text{rank}\\,X \\big / 35. Please support your answer with legitimate arguments and make the answer as accurate as possible.\nNote that depending on the structure of the matrix X, border cases are possible. Make sure to cover them in your answer correctly.\nIn applied statistics and machine learning, data is often normalized. One particularly popular strategy is to subtract the estimated mean \\mu and divide by the square root of the estimated variance \\sigma^2. i.e.\n\nx \\rightarrow (x - \\mu) \\big / \\sigma.\n\nAfter the normalization, we get a new matrix\n\n     \\begin{split}\n     Y &:=\n     \\begin{pmatrix}\n         | & & | \\\\\n         y^{(1)} & \\dots & y^{(m)} \\\\\n         | & & | \\\\\n     \\end{pmatrix},\\\\\n     y^{(i)} &:= \\frac{x^{(i)} - \\frac{1}{m}\\sum_{i=1}^{m} x^{(i)}}{\\sqrt{\\frac{1}{m}\\sum_{i=1}^{m} \\left(x^{(i)}\\right)^2 - \\left(\\frac{1}{m}\\sum_{i=1}^{m} x^{(i)}\\right)^2}}.\n     \\end{split}\n\nWhat is the rank of Y if \\text{rank} \\; X = r?\nImage Compression with Truncated SVD [10 points] Explore image compression using Truncated Singular Value Decomposition (SVD). Understand how varying the number of singular values affects the quality of the compressed image. Implement a Python script to compress a grayscale image using Truncated SVD and visualize the compression quality.\n\nTruncated SVD: Decomposes an image A into U, S, and V matrices. The compressed image is reconstructed using a subset of singular values.\nMathematical Representation: \nA \\approx U_k \\Sigma_k V_k^T\n\n\nU_k and V_k are the first k columns of U and V, respectively.\n\\Sigma_k is a diagonal matrix with the top k singular values.\nRelative Error: Measures the fidelity of the compressed image compared to the original.\n\n\n  \\text{Relative Error} = \\frac{\\| A - A_k \\|}{\\| A \\|}\n  \n\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport numpy as np\nfrom skimage import io, color\nimport requests\nfrom io import BytesIO\n\ndef download_image(url):\n    response = requests.get(url)\n    img = io.imread(BytesIO(response.content))\n    return color.rgb2gray(img)  # Convert to grayscale\n\ndef update_plot(i, img_plot, error_plot, U, S, V, original_img, errors, ranks, ax1, ax2):\n    # Adjust rank based on the frame index\n    if i &lt; 70:\n        rank = i + 1\n    else:\n        rank = 70 + (i - 69) * 10\n\n\n    reconstructed_img = ... # YOUR CODE HERE \n\n    # Calculate relative error\n    relative_error = ... # YOUR CODE HERE\n    errors.append(relative_error)\n    ranks.append(rank)\n\n    # Update the image plot and title\n    img_plot.set_data(reconstructed_img)\n    ax1.set_title(f\"Image compression with SVD\\n Rank {rank}; Relative error {relative_error:.2f}\")\n\n    # Remove axis ticks and labels from the first subplot (ax1)\n    ax1.set_xticks([])\n    ax1.set_yticks([])\n\n    # Update the error plot\n    error_plot.set_data(ranks, errors)\n    ax2.set_xlim(1, len(S))\n    ax2.grid(linestyle=\":\")\n    ax2.set_ylim(1e-4, 0.5)\n    ax2.set_ylabel('Relative Error')\n    ax2.set_xlabel('Rank')\n    ax2.set_title('Relative Error over Rank')\n    ax2.semilogy()\n\n    # Set xticks to show rank numbers\n    ax2.set_xticks(range(1, len(S)+1, max(len(S)//10, 1)))  # Adjust the step size as needed\n    plt.tight_layout()\n\n    return img_plot, error_plot\n\n\ndef create_animation(image, filename='svd_animation.mp4'):\n    U, S, V = np.linalg.svd(image, full_matrices=False)\n    errors = []\n    ranks = []\n\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(5, 8))\n    img_plot = ax1.imshow(image, cmap='gray', animated=True)\n    error_plot, = ax2.plot([], [], 'r-', animated=True)  # Initial empty plot for errors\n\n    # Add watermark\n    ax1.text(1, 1.02, '@fminxyz', transform=ax1.transAxes, color='gray', va='bottom', ha='right', fontsize=9)\n\n    # Determine frames for the animation\n    initial_frames = list(range(70))  # First 70 ranks\n    subsequent_frames = list(range(70, len(S), 10))  # Every 10th rank after 70\n    frames = initial_frames + subsequent_frames\n\n    ani = animation.FuncAnimation(fig, update_plot, frames=len(frames), fargs=(img_plot, error_plot, U, S, V, image, errors, ranks, ax1, ax2), interval=50, blit=True)\n    ani.save(filename, writer='ffmpeg', fps=8, dpi=300)\n\n# URL of the image\nurl = \"\"\n\n# Download the image and create the animation\nimage = download_image(url)\ncreate_animation(image)\n\n\n\nConvergence rates\n\n[10 points] Determine the convergence or divergence of the given sequences\n\nr_{k} = k^{\\frac{1}{2}}.\nr_{k} = \\frac{1}{\\sqrt{k}}.\nr_{k} = 0.808^k.\nr_{k} = 0.808^{2^k}.\n\n[10 points] Determine the following sequence \\{r_k\\} by convergence rate (linear, sublinear, superlinear). In the case of superlinear convergence, additionally, find out whether there is quadratic convergence.\n\nr_k = \\dfrac{1}{k!}\n\n[10 points] Determine the convergence or divergence of a given sequence r_k =\\begin{cases} \\frac{1}{k}, & \\text{if } k\\text{ is even} \\\\ e^{-k}, & \\text{if } k\\text{ is odd} \\end{cases}.\n[10 points] Determine the convergence or divergence of a given sequence r_k =\\begin{cases} \\left(\\frac{1}{4}\\right)^{2^k}, & \\text{if } k\\text{ is even} \\\\ \\frac{r_{k-1}}{k}, & \\text{if } k\\text{ is odd} \\end{cases}.\n[10 points] Let \\{r_k\\} be a sequence of non-negative numbers given as r_{k+1} = Mr_k^2, where M &gt; 0, r_0 \\geq 0. Establish a necessary and sufficient condition on M and r_0 under which the sequence r_k will converge to zero. What is the rate of convergence?\n[10 points] Let \\left\\{ r_k \\right\\}_{k=m}^\\infty be a sequence of non-negative numbers and let s &gt; 0 be some integer. Prove that sequence \\left\\{ r_k \\right\\}_{k=m+s}^\\infty is linearly convergent with constant q if and only if a the sequence \\left\\{ r_k \\right\\}_{k=m}^\\infty converged linearly with constant q.\n\n\n\nLine search\n\n[10 points] Consider a quadratic function f: \\mathbb{R}^n \\rightarrow \\mathbb{R}, and let us start from a point x_k \\in \\mathbb{R}^n moving in the direction of the antigradient -\\nabla f(x_k). Show that the minimum of f along this direction as a function of the step size \\alpha, for a decreasing function at x_k, satisfies Armijo’s condition for any c_1 in the range 0 \\leq c_1 \\leq \\frac{1}{2}. Specifically, demonstrate that the following inequality holds at the optimal \\alpha^*:\n\n\\varphi(\\alpha) = f(x_{k+1}) = f(x_k - \\alpha \\nabla f(x_k)) \\leq f(x_k) - c_1 \\alpha \\|\\nabla f(x_k)\\|_2^2\n\nImplementing and Testing Line Search Conditions in Gradient Descent [30 points]\n\nx_{k+1} = x_k - \\alpha \\nabla f(x_k)\n\nIn this assignment, you will modify an existing Python code for gradient descent to include various line search conditions. You will test these modifications on two functions: a quadratic function and the Rosenbrock function. The main objectives are to understand how different line search strategies influence the convergence of the gradient descent algorithm and to compare their efficiencies based on the number of function evaluations.\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import minimize_scalar\nnp.random.seed(214)\n\n# Define the quadratic function and its gradient\ndef quadratic_function(x, A, b):\n    return 0.5 * np.dot(x.T, np.dot(A, x)) - np.dot(b.T, x)\n\ndef grad_quadratic(x, A, b):\n    return np.dot(A, x) - b\n\n# Generate a 2D quadratic problem with a specified condition number\ndef generate_quadratic_problem(cond_number):\n    # Random symmetric matrix\n    M = np.random.randn(2, 2)\n    M = np.dot(M, M.T)\n\n    # Ensure the matrix has the desired condition number\n    U, s, V = np.linalg.svd(M)\n    s = np.linspace(cond_number, 1, len(s))  # Spread the singular values\n    A = np.dot(U, np.dot(np.diag(s), V))\n\n    # Random b\n    b = np.random.randn(2)\n\n    return A, b\n\n# Gradient descent function\ndef gradient_descent(start_point, A, b, stepsize_func, max_iter=100):\n    x = start_point.copy()\n    trajectory = [x.copy()]\n\n    for i in range(max_iter):\n        grad = grad_quadratic(x, A, b)\n        step_size = stepsize_func(x, grad)\n        x -= step_size * grad\n        trajectory.append(x.copy())\n\n    return np.array(trajectory)\n\n# Backtracking line search strategy using scipy\ndef backtracking_line_search(x, grad, A, b, alpha=0.3, beta=0.8):\n    def objective(t):\n        return quadratic_function(x - t * grad, A, b)\n    res = minimize_scalar(objective, method='golden')\n    return res.x\n\n# Generate ill-posed problem\ncond_number = 30\nA, b = generate_quadratic_problem(cond_number)\n\n# Starting point\nstart_point = np.array([1.0, 1.8])\n\n# Perform gradient descent with both strategies\ntrajectory_fixed = gradient_descent(start_point, A, b, lambda x, g: 5e-2)\ntrajectory_backtracking = gradient_descent(start_point, A, b, lambda x, g: backtracking_line_search(x, g, A, b))\n\n# Plot the trajectories on a contour plot\nx1, x2 = np.meshgrid(np.linspace(-2, 2, 400), np.linspace(-2, 2, 400))\nZ = np.array([quadratic_function(np.array([x, y]), A, b) for x, y in zip(x1.flatten(), x2.flatten())]).reshape(x1.shape)\n\nplt.figure(figsize=(10, 8))\nplt.contour(x1, x2, Z, levels=50, cmap='viridis')\nplt.plot(trajectory_fixed[:, 0], trajectory_fixed[:, 1], 'o-', label='Fixed Step Size')\nplt.plot(trajectory_backtracking[:, 0], trajectory_backtracking[:, 1], 'o-', label='Backtracking Line Search')\n\n# Add markers for start and optimal points\nplt.plot(start_point[0], start_point[1], 'ro', label='Start Point')\noptimal_point = np.linalg.solve(A, b)\nplt.plot(optimal_point[0], optimal_point[1], 'y*', markersize=15, label='Optimal Point')\n\nplt.legend()\nplt.title('Gradient Descent Trajectories on Quadratic Function')\nplt.xlabel('x1')\nplt.ylabel('x2')\nplt.savefig(\"linesearch.svg\")\nplt.show()\n\n\n\nThe code above plots this\n\n\nStart by reviewing the provided Python code. This code implements gradient descent with a fixed step size and a backtracking line search on a quadratic function. Familiarize yourself with how the gradient descent function and the step size strategies are implemented.\n\nModify the gradient descent function to include the following line search conditions:\n\nSufficient Decrease Condition\nCurvature Condition\nGoldstein Condition\nWolfe Condition\nDichotomy\n\nTest your modified gradient descent algorithm with the implemented line search conditions on the provided quadratic function. Plot the trajectories over iterations for each condition. Choose and specify hyperparameters for inexact line search condition. Choose and specify the termination criterion. Start from the point x_0 = (-1, 2)^T.\nCompare these 7 methods from the budget perspective. Plot the graph of function value from the number of function evaluations for each method on the same graph.\nPlot trajectory for another function with the same set of methods\n\nf(x_1, x_2) =  10(x_2 − x_1^2)^2 + (x_1 − 1)^2\n\nwith x_0 = (-1, 2)^T. You might need to adjust hyperparameters.\nPlot the same function value from the number of function calls for this experiment.\n\n\n\n\nMatrix calculus\n\n[10 points] Given a matrix A of size m \\times n and a vector x of size n \\times 1, compute the gradient of the function f(x) = \\text{tr}(A^T A x x^T) with respect to x.\n[10 points] Find the gradient \\nabla f(x) and hessian f''(x), if f(x) = \\dfrac{1}{2} \\Vert Ax - b\\Vert^2_2.\n[10 points] Find the gradient \\nabla f(x) and hessian f''(x), if \nf(x) = \\frac1m \\sum\\limits_{i=1}^m \\log \\left( 1 + \\exp(a_i^{T}x) \\right) + \\frac{\\mu}{2}\\Vert x\\Vert _2^2, \\; a_i, x \\in \\mathbb R^n, \\; \\mu&gt;0\n\n[10 points] Compute the gradient \\nabla_A f(A) of the trace of the matrix exponential function f(A) = \\text{tr}(e^A) with respect to A. Hint: hint: Use the definition of the matrix exponential. Use the definition of the differential df = f(A + dA) - f(A) + o(\\Vert dA \\Vert) with the limit \\Vert dA \\Vert \\to 0.\n[10 points] Calculate the first and the second derivative of the following function f : S \\to \\mathbb{R}\n\nf(t) = \\text{det}(A − tI_n),\n\nwhere A \\in \\mathbb{R}^{n \\times n}, S := \\{t \\in \\mathbb{R} : \\text{det}(A − tI_n) \\neq 0\\}.\n[10 points] Find the gradient \\nabla f(X), if f(X) = \\text{tr}\\left( AX^2BX^{-\\top} \\right).\n\n\n\nAutomatic differentiation and jax (2 more problems coming)\nYou can use any automatic differentiation framework in this section (Jax, PyTorch, Autograd etc.)\n\n[10 points] You will work with the following function for this exercise, \nf(x,y)=e^{−\\left(sin(x)−cos(y)\\right)^2}\n\nDraw the computational graph for the function. Note, that it should contain only primitive operations - you need to do it automatically - jax example, PyTorch example - you can google/find your way to visualize it.\n[10 points] Compare analytic and autograd (with any framework) approach for the calculation of the gradient of:\n\nf(A) = \\text{tr}(e^A)\n\n[10 points] We can use automatic differentiation not only to calculate necessary gradients but also for tuning hyperparameters of the algorithm like learning rate in gradient descent (with gradient descent 🤯). Suppose, we have the following function f(x) = \\frac{1}{2}\\Vert x\\Vert^2, select a random point x_0 \\in \\mathbb{B}^{1000} = \\{0 \\leq x_i \\leq 1 \\mid \\forall i\\}. Consider 10 steps of the gradient descent starting from the point x_0: \nx_{k+1} = x_k - \\alpha_k \\nabla f(x_k)\n Your goal in this problem is to write the function, that takes 10 scalar values \\alpha_i and return the result of the gradient descent on function L = f(x_{10}). And optimize this function using gradient descent on \\alpha \\in \\mathbb{R}^{10}. Suppose that each of 10 components of \\alpha is uniformly distributed on [0; 0.1]. \n\\alpha_{k+1} = \\alpha_k - \\beta \\frac{\\partial L}{\\partial \\alpha}\n Choose any constant \\beta and the number of steps you need. Describe the obtained results. How would you understand, that the obtained schedule (\\alpha \\in \\mathbb{R}^{10}) becomes better than it was at the start? How do you check numerically local optimality in this problem?\n[10 points] Compare analytic and autograd (with any framework) approach for the gradient of:\n\nf(X) = - \\log \\det X\n\n\n\n\nConvexity\n\n[10 points] Show, that \\mathbf{conv}\\{xx^\\top: x \\in \\mathbb{R}^n, \\Vert x\\Vert  = 1\\} = \\{A \\in \\mathbb{S}^n_+: \\text{tr}(A) = 1\\}.\n[5 points] Prove that the set of \\{x \\in \\mathbb{R}^2 \\mid e^{x_1}\\le x_2\\} is convex.\n[5 points] Show that the set of directions of the non-strict local descending of the differentiable function in a point is a convex cone.\n[10 points] Is the following set convex \nS = \\left\\{ a \\in \\mathbb{R}^k \\mid p(0) = 1, \\vert p(t) \\vert\\leq 1 \\text{ for } \\alpha\\leq t \\leq \\beta\\right\\},\n where \np(t) = a_1 + a_2 t + \\ldots + a_k t^{k-1} \\;?\n\n[10 points] Consider the function f(x) = x^d, where x \\in \\mathbb{R}_{+}. Fill the following table with ✅ or ❎. Explain your answers\n\n\n\n\nd\nConvex\nConcave\nStrictly Convex\n\\mu-strongly convex\n\n\n\n\n-2, x \\in \\mathbb{R}_{++}\n\n\n\n\n\n\n-1, x \\in \\mathbb{R}_{++}\n\n\n\n\n\n\n0\n\n\n\n\n\n\n0.5\n\n\n\n\n\n\n1\n\n\n\n\n\n\n\\in (1; 2)\n\n\n\n\n\n\n2\n\n\n\n\n\n\n&gt; 2\n\n\n\n\n\n\n\n\n[10 points] Prove that the entropy function, defined as\n\nf(x) = -\\sum_{i=1}^n x_i \\log(x_i),\n\nwith \\text{dom}(f) = \\{x \\in \\R^n_{++} : \\sum_{i=1}^n x_i = 1\\}, is strictly concave.\n[10 points] Show, that the function f: \\mathbb{R}^n_{++} \\to \\mathbb{R} is convex if f(x) = - \\prod\\limits_{i=1}^n x_i^{\\alpha_i} if \\mathbf{1}^T \\alpha = 1, \\alpha \\succeq 0.\n[10 points] Show that the maximum of a convex function f over the polyhedron P = \\text{conv}\\{v_1, \\ldots, v_k\\} is achieved at one of its vertices, i.e.,\n\n\\sup_{x \\in P} f(x) = \\max_{i=1, \\ldots, k} f(v_i).\n\nA stronger statement is: the maximum of a convex function over a closed bounded convex set is achieved at an extreme point, i.e., a point in the set that is not a convex combination of any other points in the set. (you do not have to prove it). Hint: Assume the statement is false, and use Jensen’s inequality.\n[10 points] Show, that the two definitions of \\mu-strongly convex functions are equivalent:\n\nf(x) is \\mu-strongly convex \\iff for any x_1, x_2 \\in S and 0 \\le \\lambda \\le 1 for some \\mu &gt; 0:\n\nf(\\lambda x_1 + (1 - \\lambda)x_2) \\le \\lambda f(x_1) + (1 - \\lambda)f(x_2) - \\frac{\\mu}{2} \\lambda (1 - \\lambda)\\|x_1 - x_2\\|^2\n\nf(x) is \\mu-strongly convex \\iff if there exists \\mu&gt;0 such that the function f(x) - \\dfrac{\\mu}{2}\\Vert x\\Vert^2 is convex.\n\n\n\n\nOptimality conditions\nIn this section, you can consider either the arbitrary norm or the Euclidian norm if nothing else is specified.\n\nToy example [10 points] \n\\begin{split}\n& x^2 + 1 \\to \\min\\limits_{x \\in \\mathbb{R} }\\\\\n\\text{s.t. } & (x-2)(x-4) \\leq 0\n\\end{split}\n\n\nGive the feasible set, the optimal value, and the optimal solution.\nPlot the objective x^2 +1 versus x. On the same plot, show the feasible set, optimal point, and value, and plot the Lagrangian L(x,\\mu) versus x for a few positive values of \\mu. Verify the lower bound property (p^* \\geq \\inf_x L(x, \\mu)for \\mu \\geq 0). Derive and sketch the Lagrange dual function g.\nState the dual problem, and verify that it is a concave maximization problem. Find the dual optimal value and dual optimal solution \\mu^*. Does strong duality hold?\nLet p^*(u) denote the optimal value of the problem\n\n\n\\begin{split}\n& x^2 + 1 \\to \\min\\limits_{x \\in \\mathbb{R} }\\\\\n\\text{s.t. } & (x-2)(x-4) \\leq u\n\\end{split}\n\nas a function of the parameter u. Plot p^*(u). Verify that \\dfrac{dp^*(0)}{du} = -\\mu^*\n[10 points] Derive the dual problem for the Ridge regression problem with A \\in \\mathbb{R}^{m \\times n}, b \\in \\mathbb{R}^m, \\lambda &gt; 0:\n\n\\begin{split}\n\\dfrac{1}{2}\\|y-b\\|^2 + \\dfrac{\\lambda}{2}\\|x\\|^2 &\\to \\min\\limits_{x \\in \\mathbb{R}^n, y \\in \\mathbb{R}^m }\\\\\n\\text{s.t. } & y = Ax\n\\end{split}\n\n[20 points] Derive the dual problem for the support vector machine problem with A \\in \\mathbb{R}^{m \\times n}, \\mathbf{1} \\in \\mathbb{R}^m \\in \\mathbb{R}^m, \\lambda &gt; 0:\n\n\\begin{split}\n\\langle \\mathbf{1}, t\\rangle + \\dfrac{\\lambda}{2}\\|x\\|^2 &\\to \\min\\limits_{x \\in \\mathbb{R}^n, t \\in \\mathbb{R}^m }\\\\\n\\text{s.t. } & Ax \\succeq \\mathbf{1} - t \\\\\n& t \\succeq 0\n\\end{split}\n\n[10 points] Give an explicit solution to the following LP.\n\n\\begin{split}\n& c^\\top x \\to \\min\\limits_{x \\in \\mathbb{R}^n }\\\\\n\\text{s.t. } & 1^\\top x = 1, \\\\\n& x \\succeq 0\n\\end{split}\n\nThis problem can be considered the simplest portfolio optimization problem.\n[20 points] Show, that the following problem has a unique solution and find it:\n\n\\begin{split}\n& \\langle C^{-1}, X\\rangle - \\log \\det X \\to \\min\\limits_{x \\in \\mathbb{R}^{n \\times n} }\\\\\n\\text{s.t. } & \\langle Xa, a\\rangle \\leq 1,\n\\end{split}\n\nwhere C \\in \\mathbb{S}^n_{++}, a \\in \\mathbb{R}^n \\neq 0. The answer should not involve inversion of the matrix C.\n[20 points] Give an explicit solution to the following QP.\n\n\\begin{split}\n& c^\\top x \\to \\min\\limits_{x \\in \\mathbb{R}^n }\\\\\n\\text{s.t. } & (x - x_c)^\\top A (x - x_c) \\leq 1,\n\\end{split}\n\nwhere A \\in \\mathbb{S}^n_{++}, c \\neq 0, x_c \\in \\mathbb{R}^n.\n[10 points] Consider the equality-constrained least-squares problem\n\n\\begin{split}\n& \\|Ax - b\\|_2^2 \\to \\min\\limits_{x \\in \\mathbb{R}^n }\\\\\n\\text{s.t. } & Cx = d,\n\\end{split}\n\nwhere A \\in \\mathbb{R}^{m \\times n} with \\mathbf{rank }A = n, and C \\in \\mathbb{R}^{k \\times n} with \\mathbf{rank }C = k. Give the KKT conditions, and derive expressions for the primal solution x^* and the dual solution \\lambda^*.\n[20 points] Derive the KKT conditions for the problem\n\n\\begin{split}\n& \\mathbf{tr \\;}X - \\log\\text{det }X \\to \\min\\limits_{X \\in \\mathbb{S}^n_{++} }\\\\\n\\text{s.t. } & Xs = y,\n\\end{split}\n\nwhere y \\in \\mathbb{R}^n and s \\in \\mathbb{R}^n are given with y^\\top s = 1. Verify that the optimal solution is given by\n\nX^* = I + yy^\\top - \\dfrac{1}{s^\\top s}ss^\\top\n\nSupporting hyperplane interpretation of KKT conditions. [10 points] Consider a convex problem with no equality constraints\n\n\\begin{split}\n& f_0(x) \\to \\min\\limits_{x \\in \\mathbb{R}^n }\\\\\n\\text{s.t. } & f_i(x) \\leq 0, \\quad i = [1,m]\n\\end{split}\n\nAssume, that \\exists x^* \\in \\mathbb{R}^n, \\mu^* \\in \\mathbb{R}^m satisfy the KKT conditions\n\n\\begin{split}\n& \\nabla_x L (x^*, \\mu^*) = \\nabla f_0(x^*) + \\sum\\limits_{i=1}^m\\mu_i^*\\nabla f_i(x^*) = 0 \\\\\n& \\mu^*_i \\geq 0, \\quad i = [1,m] \\\\\n& \\mu^*_i f_i(x^*) = 0, \\quad i = [1,m]\\\\\n& f_i(x^*) \\leq 0, \\quad i = [1,m]\n\\end{split}\n\nShow that\n\n\\nabla f_0(x^*)^\\top (x - x^*) \\geq 0\n\nfor all feasible x. In other words, the KKT conditions imply the simple optimality criterion or \\nabla f_0(x^*) defines a supporting hyperplane to the feasible set at x^*.\nA penalty method for equality constraints. [10 points] We consider the problem of minimization\n\n\\begin{split}\n& f_0(x) \\to \\min\\limits_{x \\in \\mathbb{R}^{n} }\\\\\n\\text{s.t. } & Ax = b,\n\\end{split}\n\nwhere $f_0(x): ^n $ is convex and differentiable, and A \\in \\mathbb{R}^{m \\times n} with \\mathbf{rank }A = m. In a quadratic penalty method, we form an auxiliary function\n\n\\phi(x) = f_0(x) + \\alpha \\|Ax - b\\|_2^2,\n\nwhere \\alpha &gt; 0 is a parameter. This auxiliary function consists of the objective plus the penalty term \\alpha \\Vert Ax - b\\Vert_2^2. The idea is that a minimizer of the auxiliary function, \\tilde{x}, should be an approximate solution to the original problem. Intuition suggests that the larger the penalty weight \\alpha, the better the approximation \\tilde{x} to a solution of the original problem. Suppose \\tilde{x} is a minimizer of \\phi(x). Show how to find, from \\tilde{x}, a dual feasible point for the original problem. Find the corresponding lower bound on the optimal value of the original problem.\n\n\n\nLinear programming\n\n📱🎧💻 Covers manufacturing. [20 points] Lyzard Corp is producing covers for the following products:\n\n📱 phones\n🎧 headphones\n💻 laptops\n\nThe company’s production facilities are such that if we devote the entire production to headphone covers, we can produce 5000 of them in one day. If we devote the entire production to phone covers or laptop covers, we can produce 4000 or 2000 of them in one day.\nThe production schedule is one week (6 working days), and the week’s production must be stored before distribution. Storing 1000 headphone covers (packaging included) takes up 30 cubic feet of space. Storing 1000 phone covers (packaging included) takes up 50 cubic feet of space, and storing 1000 laptop covers (packaging included) takes up 220 cubic feet of space. The total storage space available is 1500 cubic feet.\nDue to commercial agreements with Lyzard Corp has to deliver at least 4500 headphone covers and 4000 laptop covers per week to strengthen the product’s diffusion.\nThe marketing department estimates that the weekly demand for headphones covers, phone, and laptop covers does not exceed 10000 14000, and 7000 units, therefore the company does not want to produce more than these amounts for headphones, phone, and laptop covers.\nFinally, the net profit per headphone cover, phone cover, and laptop cover are $5, $7, and $12, respectively.\nThe aim is to determine a weekly production schedule that maximizes the total net profit.\n\nWrite a Linear Programming formulation for the problem. Use the following variables:\n\ny_1 = number of headphones covers produced over the week,\n\ny_2 = number of phone covers produced over the week,\n\ny_3 = number of laptop covers produced over the week.\n\nFind the solution to the problem using PyOMO\n!pip install pyomo\n! sudo apt-get install glpk-utils --quiet  # GLPK\n! sudo apt-get install coinor-cbc --quiet  # CoinOR\nPerform the sensitivity analysis. Which constraint could be relaxed to increase the profit the most? Prove it numerically.\n\nProve the optimality of the solution [10 points]\n\nx = \\left(\\frac{7}{3} , 0, \\frac{1}{3}\\right)^T\n\nto the following linear programming problem:\n\n\\begin{split}\n& 9x_1 + 3x_2 + 7x_3 \\to \\max\\limits_{x \\in \\mathbb{R}^3 }\\\\\n\\text{s.t. } & 2x_1 + x_2 + 3x_3 \\leq 6 \\\\\n& 5x_1 + 4x_2 + x_3 \\leq 12 \\\\\n& 3x_3 \\leq 1,\\\\\n& x_1, x_2, x_3 \\geq 0\n\\end{split}\n\nbut you cannot use any numerical algorithm here.\n\n\n\nGradient Descent\n\nConvergence of Gradient Descent in non-convex smooth case [10 points]\nWe will assume nothing about the convexity of f. We will show that gradient descent reaches an \\varepsilon-substationary point x, such that \\|\\nabla f(x)\\|_2 \\leq \\varepsilon, in O(1/\\varepsilon^2) iterations. Important note: you may use here Lipschitz parabolic upper bound:\n\nf(y) \\leq f(x) + \\nabla f(x)^T (y-x) + \\frac{L}{2} \\|y-x\\|_2^2, \\;\\;\\;\n\\text{for all $x,y$}.  \n  \\tag{1}\n\nPlug in y = x^{k+1} = x^{k} - \\alpha \\nabla f(x^k), x = x^k to (Equation 1) to show that\n\n  f(x^{k+1}) \\leq f(x^k) - \\Big (1-\\frac{L\\alpha}{2} \\Big) \\alpha \\|\\nabla f(x^k)\\|_2^2.\n  \nUse \\alpha \\leq 1/L, and rearrange the previous result, to get\n\n  \\|\\nabla f(x^k)\\|_2^2 \\leq \\frac{2}{\\alpha} \\left( f(x^k) - f(x^{k+1}) \\right).\n  \nSum the previous result over all iterations from 1,\\ldots,k+1 to establish\n\n  \\sum_{i=0}^k \\|\\nabla f(x^{i})\\|_2^2 \\leq\n  \\frac{2}{\\alpha} ( f(x^{0}) - f^*).\n  \nLower bound the sum in the previous result to get\n\n  \\min_{i=0,\\ldots,k} \\|\\nabla f(x^{i}) \\|_2\n  \\leq \\sqrt{\\frac{2}{\\alpha(k+1)} (f(x^{0}) - f^*)},\n   which establishes the desired O(1/\\varepsilon^2) rate for achieving \\varepsilon-substationarity.\n\nHow gradient descent convergence depends on the condition number and dimensionality. [20 points] Investigate how the number of iterations required for gradient descent to converge depends on the following two parameters: the condition number \\kappa \\geq 1 of the function being optimized, and the dimensionality n of the space of variables being optimized.\nTo do this, for given parameters n and \\kappa, randomly generate a quadratic problem of size n with condition number \\kappa and run gradient descent on it with some fixed required precision. Measure the number of iterations T(n, \\kappa) that the method required for convergence (successful termination based on the stopping criterion).\nRecommendation: The simplest way to generate a random quadratic problem of size n with a given condition number \\kappa is as follows. It is convenient to take a diagonal matrix A \\in S_{n}^{++} as simply the diagonal matrix A = \\text{Diag}(a), whose diagonal elements are randomly generated within [1, \\kappa], and where \\min(a) = 1, \\max(a) = \\kappa. As the vector b \\in \\mathbb{R}^n, you can take a vector with random elements. Diagonal matrices are convenient to consider since they can be efficiently processed with even for large values of n.\nFix a certain value of the dimensionality n. Iterate over different condition numbers \\kappa on a grid and plot the dependence of T(n,\\kappa) against \\kappa. Since the quadratic problem is generated randomly each time, repeat this experiment several times. As a result, for a fixed value of n, you should obtain a whole family of curves showing the dependence of T(n, \\kappa) on \\kappa. Draw all these curves in the same color for clarity (for example, red).\nNow increase the value of n and repeat the experiment. You should obtain a new family of curves T(n',\\kappa) against \\kappa. Draw all these curves in the same color but different from the previous one (for example, blue).\nRepeat this procedure several times for other values of n. Eventually, you should have several different families of curves - some red (corresponding to one value of n), some blue (corresponding to another value of n), some green, etc.\nNote that it makes sense to iterate over the values of the dimensionality n on a logarithmic grid (for example, n = 10, n = 100, n = 1000, etc.). Use the following stopping criterion: \\|\\nabla f(x_k)\\|_2^2 \\leq \\varepsilon \\|\\nabla f(x_0)\\|_2^2 with \\varepsilon = 10^{-5}. Select the starting point x_0 = (1, \\ldots, 1)^T\nWhat conclusions can be drawn from the resulting picture?\n\n\n\nAccelerated methods\n\nLocal Convergence of Heavy Ball Method. [20 points] We will work with the heavy ball method in this problem\n\n\\tag{HB}\nx_{k+1} = x_k - \\alpha \\nabla f(x_k) + \\beta (x_k - x_{k-1})\n\nIt is known, that for the quadratics the best choice of hyperparameters is \\alpha^* = \\dfrac{4}{(\\sqrt{L} + \\sqrt{\\mu})^2}, \\beta^* = \\dfrac{(\\sqrt{L} - \\sqrt{\\mu})^2}{(\\sqrt{L} + \\sqrt{\\mu})^2}, which ensures accelerated linear convergence for a strongly convex quadratic function.\nConsider the following continuously differentiable, strongly convex with parameter \\mu, and smooth function with parameter L:\n\nf(x) =\n\\begin{cases}\n\\frac{25}{2}x^2, & \\text{if } x &lt; 1 \\\\\n\\frac12x^2 + 24x - 12, & \\text{if } 1 \\leq x &lt; 2 \\\\\n\\frac{25}{2}x^2 - 24x + 36, & \\text{if } x \\geq 2\n\\end{cases}\n\\quad\n\\nabla f(x) =\n\\begin{cases}\n25x, & \\text{if } x &lt; 1 \\\\\nx + 24, & \\text{if } 1 \\leq x &lt; 2 \\\\\n25x - 24, & \\text{if } x \\geq 2\n\\end{cases}\n\n\nHow to prove, that the given function is convex? Strongly convex? Smooth?\nFind the constants \\mu and L for a given function.\nPlot the function value for x \\in [-4, 4].\nRun the Heavy Ball method for the function with optimal hyperparameters \\alpha^* = \\dfrac{4}{(\\sqrt{L} + \\sqrt{\\mu})^2}, \\beta^* = \\dfrac{(\\sqrt{L} - \\sqrt{\\mu})^2}{(\\sqrt{L} + \\sqrt{\\mu})^2} for quadratic function, starting from x_0 = 3.5. If you have done everything above correctly, you should receive something like\n\nYou can use the following code for plotting:\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom IPython.display import HTML\n\n# Gradient of the function\ndef grad_f(x):\n    ...\n\n# Heavy Ball method implementation\ndef heavy_ball_method(alpha, beta, x0, num_iterations):\n    x = np.zeros(num_iterations + 1)\n    x_prev = x0\n    x_curr = x0  # Initialize x[1] same as x[0] to start the algorithm\n    for i in range(num_iterations):\n        x[i] = x_curr\n        x_new = x_curr - alpha * grad_f(x_curr) + beta * (x_curr - x_prev)\n        x_prev = x_curr\n        x_curr = x_new\n    x[num_iterations] = x_curr\n    return x\n\n# Parameters\nL = ...\nmu = ...\nalpha_star = ...\nbeta_star = ...\nx0 = ...\nnum_iterations = 30\n\n# Generate the trajectory of the method\ntrajectory = heavy_ball_method(alpha_star, beta_star, x0, num_iterations)\n\n# Setup the figure and axes for the animation\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(7, 3.5))\nfig.suptitle(\"Heavy ball method with optimal hyperparameters α* β*\")\n\n# Function for updating the animation\ndef update(i):\n    ax1.clear()\n    ax2.clear()\n\n    # Plot f(x) and trajectory\n    x_vals = np.linspace(-4, 4, 100)\n    f_vals = np.piecewise(x_vals, [x_vals &lt; 1, (x_vals &gt;= 1) & (x_vals &lt; 2), x_vals &gt;= 2],\n                        [lambda x: 12.5 * x**2, lambda x: .5 * x**2 + 24 * x - 12, lambda x: 12.5 * x**2 - 24 * x + 36])\n    ax1.plot(x_vals, f_vals, 'b-')\n    ax1.plot(trajectory[:i], [12.5 * x**2 if x &lt; 1 else .5 * x**2 + 24 * x - 12 if x &lt; 2 else 12.5 * x**2 - 24 * x + 36 for x in trajectory[:i]], 'ro-')\n    # Add vertical dashed lines at x=1 and x=2 on the left subplot\n    ax1.axvline(x=1, color='navy', linestyle='--')\n    ax1.axvline(x=2, color='navy', linestyle='--')\n\n    # Plot function value from iteration\n    f_trajectory = [None for x in trajectory]\n    f_trajectory[:i] = [12.5 * x**2 if x &lt; 1 else .5 * x**2 + 24 * x - 12 if x &lt; 2 else 12.5 * x**2 - 24 * x + 36 for x in trajectory[:i]]\n    ax2.plot(range(len(trajectory)), f_trajectory, 'ro-')\n    ax2.set_xlim(0, len(trajectory))\n    ax2.set_ylim(min(f_vals), max(f_vals))\n    # Add horizontal dashed lines at f(1) and f(2) on the right subplot\n    f_1 = 12.5 * 1.0**2\n    f_2 = .5 * 2.**2 + 24 * 2. - 12\n    ax2.axhline(y=f_1, color='navy', linestyle='--')\n    ax2.axhline(y=f_2, color='navy', linestyle='--')\n\n    # ax1.set_title(\"Function f(x) and Trajectory\")\n    ax1.set_xlabel(\"x\")\n    ax1.set_ylabel(\"f(x)\")\n    ax1.grid(linestyle=\":\")\n\n    # ax2.set_title(\"Function Value from Iteration\")\n    ax2.set_xlabel(\"Iteration\")\n    ax2.set_ylabel(\"f(x)\")\n    ax2.grid(linestyle=\":\")\n\n    plt.tight_layout()\n\n# Create the animation\nani = animation.FuncAnimation(fig, update, frames=num_iterations, repeat=False, interval=100)\nHTML(ani.to_jshtml())\nChange the starting point to x_0 = 3.4. What do you see? How could you name such a behavior of the method?\nChange the hyperparameter \\alpha^{\\text{Global}} = \\frac2L, \\beta^{\\text{Global}} = \\frac{\\mu}{L} and run the method again from x_0 = 3.4. Check whether you have accelerated convergence here.\n\nContext: this counterexample was provided in the paper, while the global convergence of the heavy ball method for general smooth strongly convex function was introduced in another paper. Recently, it was suggested, that the heavy-ball (HB) method provably does not reach an accelerated convergence rate on smooth strongly convex problems.\n[40 points] In this problem we will work with accelerated methods applied to the logistic regression problem. A good visual introduction to the topic is available here.\nLogistic regression is a standard model in classification tasks. For simplicity, consider only the case of binary classification. Informally, the problem is formulated as follows: There is a training sample \\{(a_i, b_i)\\}_{i=1}^m, consisting of m vectors a_i \\in \\mathbb{R}^n (referred to as features) and corresponding numbers b_i \\in \\{-1, 1\\} (referred to as classes or labels). The goal is to construct an algorithm b(\\cdot), which for any new feature vector a automatically determines its class b(a) \\in \\{-1, 1\\}.\nIn the logistic regression model, the class determination is performed based on the sign of the linear combination of the components of the vector a with some fixed coefficients x \\in \\mathbb{R}^n:\n\nb(a) := \\text{sign}(\\langle a, x \\rangle).\n\nThe coefficients x are the parameters of the model and are adjusted by solving the following optimization problem:\n\n\\tag{LogReg}\n\\min_{x \\in \\mathbb{R}^n} \\left( \\frac{1}{m} \\sum_{i=1}^m \\ln(1 + \\exp(-b_i \\langle a_i, x \\rangle)) + \\frac{\\lambda}{2} \\|x\\|^2 \\right),\n\nwhere \\lambda \\geq 0 is the regularization coefficient (a model parameter).\n\nWill the LogReg problem be convex for \\lambda = 0? What is the gradient of the objective function? Will it be strongly convex? What if you will add regularization with \\lambda &gt; 0?\nWe will work with the real-world data for A and b: take the mushroom dataset. Be careful, you will need to predict if the mushroom is poisonous or edible. A poor model can cause death in this exercise.\nimport requests\nfrom sklearn.datasets import load_svmlight_file\n\n# URL of the file to download\nurl = 'https://hse24.fmin.xyz/files/mushrooms.txt'\n\n# Download the file and save it locally\nresponse = requests.get(url)\ndataset = 'mushrooms.txt'\n\n# Ensure the request was successful\nif response.status_code == 200:\n    with open(dataset, 'wb') as f:\n        f.write(response.content)\n\n    # Load the dataset from the downloaded file\n    data = load_svmlight_file(dataset)\n    A, b = data[0].toarray(), data[1]\n    n, d = A.shape\n\n    print(\"Data loaded successfully.\")\n    print(f\"Number of samples: {n}, Number of features: {d}\")\nelse:\n    print(f\"Failed to download the file. Status code: {response.status_code}\")\nDivide the data into two parts: training and test. We will train the model on the A_{train}, b_{train} and measure the accuracy of the model on the A_{test}, b_{test}.\nfrom sklearn.model_selection import train_test_split\n# Split the data into training and test sets\nA_train, A_test, b_train, b_test = train_test_split(A, b, test_size=0.2, random_state=214)\nFor the training part A_{train}, b_{train}, estimate the constants \\mu, L of the training/optimization problem. Use the same small value \\lambda for all experiments\nUsing gradient descent with the step \\frac{1}{L}, train a model. Plot: accuracy versus iteration number.\n\n\\tag{HB}\nx_{k+1} = x_k - \\alpha \\nabla f(x_k) + \\beta (x_k - x_{k-1})\n\nFix a step \\alpha = \\frac{1}{L} and search for different values of the momentum \\beta from -1 to 1. Choose your own convergence criterion and plot convergence for several values of momentum on the same graph. Is the convergence always monotonic?\nFor the best value of momentum \\beta, plot the dependence of the model accuracy on the test sample on the running time of the method. Add to the same graph the convergence of gradient descent with step \\frac{1}{L}. Draw a conclusion. Ensure, that you use the same value of \\lambda for both methods.\nSolve the logistic regression problem using the Nesterov method.\n\n\\tag{NAG}\nx_{k+1} = x_k - \\alpha \\nabla f(x_k + \\beta (x_k - x_{k-1})) + \\beta (x_k - x_{k-1})  \n\nFix a step \\frac{1}{L} and search for different values of momentum \\beta from -1 to 1. Check also the momentum values equal to \\frac{k}{k+3}, \\frac{k}{k+2}, \\frac{k}{k+1} (k is the number of iterations), and if you are solving a strongly convex problem, also \\frac{\\sqrt{L} - \\sqrt{\\mu}}{\\sqrt{L} + \\sqrt{\\mu}}. Plot the convergence of the method as a function of the number of iterations (choose the convergence criterion yourself) for different values of the momentum. Is the convergence always monotonic?\nFor the best value of momentum \\beta, plot the dependence of the model accuracy on the test sample on the running time of the method. Add this graph to the graphs for the heavy ball and gradient descent from the previous steps. Make a conclusion.\nNow we drop the estimated value of L and will try to do it adaptively. Let us make the selection of the constant L adaptive.\n\nf(y) \\leq f(x^k) + \\langle \\nabla f(x^k), y - x^k \\rangle + \\frac{L}{2}\\|x^k - y\\|_2^2\n\nIn particular, the procedure might work:\ndef backtracking_L(f, grad, x, h, L0, rho, maxiter=100):\n    L = L0\n    fx = f(x)\n    gradx = grad(x)\n    iter = 0\n    while iter &lt; maxiter :\n        y = x - 1 / L * h\n        if f(y) &lt;= fx - 1 / L gradx.dot(h) + 1 / (2 * L) h.dot(h):\n            break\n        else:\n            L = L * rho\n\n        iter += 1\n    return L\nWhat should h be taken as? Should \\rho be greater or less than 1? Should L_0 be taken as large or small? Draw a similar figure as it was in the previous step for L computed adaptively (6 lines - GD, HB, NAG, GD adaptive L, HB adaptive L, NAG adaptive L)\n\n\n\n\nSubgradient Descent\n\nSubgradient descent convergence with several stepsize strategies. [20 points] In this problem you will have to prove the convergence of subgradient descent (x^{k+1} = x^k - \\alpha_k g_k) for several stepsize strategies. First prove, that\n\n\\|x^{k+1} - x^*\\|_2^2 \\leq \\|x^{k} - x^*\\|_2^2 - 2\\alpha_k \\left(f(x^k) - f^* \\right) + \\alpha^2_k \\|g_k\\|_2^2\n\nThen, using \\|g\\|_2 \\leq G, \\|x^0 - x^*\\| \\leq R prove, that\n\n\\|x^{k+1} - x^*\\|_2^2 \\leq R^2 - 2\\sum\\limits_{i=1}^k\\alpha_i \\left(f(x^i) - f^* \\right) + G^2\\sum\\limits_{i=1}^k\\alpha^2_i\n\nThen, using f_k^{\\text{best}} = \\min\\limits_{i=1,\\ldots,k} f(x^i) prove, that\n\nf_k^{\\text{best}} - f^* \\leq \\frac{R^2 + G^2\\sum\\limits_{i=1}^k\\alpha^2_i}{2\\sum\\limits_{i=1}^k\\alpha_i}\n\nAfter that, finalize the bound for the following stepsize choosing strategies\n\nconstant step size \\alpha_k = \\alpha\nconstant step length \\alpha_k = \\frac{\\gamma}{\\|g_k\\|_2} (so \\|x^{k+1} - x^k\\|_2 = \\gamma)\nInverse square root \\frac{R}{G\\sqrt{k}}\nInverse \\frac1k\nPolyak’s step size:\n\n  \\alpha_k = \\frac{f(x^k) - f^*}{\\|g_k\\|_2^2}\n  \n\nFinding a point in the intersection of convex sets. [30 points] Let A \\in \\mathbb{R}^{n \\times n} be a positive definite matrix and let \\Sigma be an n \\times n diagonal matrix with diagonal entries \\sigma_1,...,\\sigma_n &gt; 0, and y a given vector in \\mathbb{R}^n. Consider the compact convex sets U = \\{x \\in \\mathbb{R}^n \\mid \\|A^{1/2}(x-y)\\|_2 \\leq 1\\} and V = \\{x \\in \\mathbb{R}^n \\mid \\|\\Sigma x\\|_\\infty \\leq 1\\}.\n\nMinimize maximum distance from the current point to the convex sets.\n\n  \\min_{x\\in\\mathbb{R}^n} f(x) =  \\min_{x\\in\\mathbb{R}^n} \\max\\{\\mathbf{dist}(x, U), \\mathbf{dist}(x, V)\\}\n  \npropose an algorithm to find a point x \\in U \\cap V. You can assume that U \\cap V is not empty. Your algorithm must be provably converging (although you do not need to prove it and you can simply refer to the lecture slides).\nImplement your algorithm with the following data: n = 2, y = (3, 2), \\sigma_1 = 0.5, \\sigma_2 = 1,\n\n  A = \\begin{bmatrix}\n  1 & 0 \\\\\n  -1 & 1\n  \\end{bmatrix},\n  \nand x = (2, 1). Plot the objective value of your optimization problem versus the number of iterations.\n\n\n\n\nIllustration of the problem\n\n\n\n\n\nConjugate gradients\n\nRandomized Preconditioners for Conjugate Gradient Methods. [20 points]\nLinear least squares\nIn this task, we explore the use of some randomization methods for solving overdetermined least-squares problems, focusing on conjugate gradient methods. Let A \\in \\mathbb{R}^{m \\times n} be a matrix (we assume that m \\gg n) and b \\in \\mathbb{R}^m, we aim to minimize\n\nf(x) = \\frac{1}{2} \\|Ax - b\\|^2_2 = \\frac{1}{2} \\sum_{i=1}^m (a_i^T x - b_i)^2,\n\nwhere the a_i \\in \\mathbb{R}^n denote the rows of A.\nPreconditioners\nWe know, that the convergence bound of the CG applied for the problem depends on the condition number of the matrix. Note, that for the problem above we have the matrix A^T A and the condition number is squared after this operation (\\kappa (X^T X) =  \\kappa^2 \\left(X \\right)). That is the reason, why we typically need to use preconditioners (read 12. for more details) with CG.\nThe general idea of using preconditioners implies switchwing from solving Ax = b to MAx = Mb with hope, that \\kappa \\left( MA\\right) \\ll \\kappa \\left( A\\right) or eigenvalues of MA are better clustered than those of A (note, that matrix A here is for the general case, here we have A^TA instead).\nThis idea can also be viewed as coordinate change x = T \\hat{x}, \\; \\hat{x} = T^{-1}x, which leads to the problem T^T A T \\hat{x} = T^Tb. Note, that the spectrum of T^TAT is the same as the spectrum of MA.\nThe best choice of M is A^{-1}, because \\kappa (A^{-1} A) = \\kappa (I) = 1. However, if we know A^{-1}, the original problem is already solved, that is why we need to find some trade-off between enhanced convergence, and extra cost of working with M. The goal is to find M that is cheap to multiply, and approximate inverse of A (or at least has a more clustered spectrum than A).\nBelow you can find Vanilla CG algorithm (on the left) and preconditioned CG algorithm (on the right):\n\n\\begin{aligned}\n& \\mathbf{r}_0 := \\mathbf{b} - \\mathbf{A x}_0 \\\\\n& \\hbox{if } \\mathbf{r}_{0} \\text{ is sufficiently small, then return } \\mathbf{x}_{0} \\text{ as the result}\\\\\n& \\mathbf{d}_0 := \\mathbf{r}_0 \\\\\n& k := 0 \\\\\n& \\text{repeat} \\\\\n& \\qquad \\alpha_k := \\frac{\\mathbf{r}_k^\\mathsf{T} \\mathbf{r}_k}{\\mathbf{d}_k^\\mathsf{T} \\mathbf{A d}_k}  \\\\\n& \\qquad \\mathbf{x}_{k+1} := \\mathbf{x}_k + \\alpha_k \\mathbf{d}_k \\\\\n& \\qquad \\mathbf{r}_{k+1} := \\mathbf{r}_k - \\alpha_k \\mathbf{A d}_k \\\\\n& \\qquad \\hbox{if } \\mathbf{r}_{k+1} \\text{ is sufficiently small, then exit loop} \\\\\n& \\qquad \\beta_k := \\frac{\\mathbf{r}_{k+1}^\\mathsf{T} \\mathbf{r}_{k+1}}{\\mathbf{r}_k^\\mathsf{T} \\mathbf{r}_k} \\\\\n& \\qquad \\mathbf{d}_{k+1} := \\mathbf{r}_{k+1} + \\beta_k \\mathbf{d}_k \\\\\n& \\qquad k := k + 1 \\\\\n& \\text{end repeat} \\\\\n& \\text{return } \\mathbf{x}_{k+1} \\text{ as the result}\n\\end{aligned} \\qquad\n\\begin{aligned}\n& \\mathbf{r}_0 := \\mathbf{b} - \\mathbf{A x}_0 \\\\\n& \\text{if } \\mathbf{r}_0 \\text{ is sufficiently small, then return } \\mathbf{x}_0 \\text{ as the result} \\\\\n& \\mathbf{z}_0 := \\mathbf{M}^{-1} \\mathbf{r}_0 \\\\\n& \\mathbf{d}_0 := \\mathbf{z}_0 \\\\\n& k := 0 \\\\\n& \\text{repeat} \\\\\n& \\qquad \\alpha_k := \\frac{\\mathbf{r}_k^\\mathsf{T} \\mathbf{z}_k}{\\mathbf{d}_k^\\mathsf{T} \\mathbf{A d}_k} \\\\\n& \\qquad \\mathbf{x}_{k+1} := \\mathbf{x}_k + \\alpha_k \\mathbf{d}_k \\\\\n& \\qquad \\mathbf{r}_{k+1} := \\mathbf{r}_k - \\alpha_k \\mathbf{A d}_k \\\\\n& \\qquad \\text{if } \\mathbf{r}_{k+1} \\text{ is sufficiently small, then exit loop} \\\\\n& \\qquad \\mathbf{z}_{k+1} := \\mathbf{M}^{-1} \\mathbf{r}_{k+1} \\\\\n& \\qquad \\beta_k := \\frac{\\mathbf{r}_{k+1}^\\mathsf{T} \\mathbf{z}_{k+1}}{\\mathbf{r}_k^\\mathsf{T} \\mathbf{z}_k} \\\\\n& \\qquad \\mathbf{d}_{k+1} := \\mathbf{z}_{k+1} + \\beta_k \\mathbf{d}_k \\\\\n& \\qquad k := k + 1 \\\\\n& \\text{end repeat} \\\\\n& \\text{return } \\mathbf{x}_{k+1} \\text{ as the result}\n\\end{aligned}\n\nHadamard matrix\nGiven m \\in \\{2^i, i = 1, 2, \\ldots\\}, the (unnormalized) Hadamard matrix of order m is defined recursively as\n\nH_2 = \\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix}, \\quad \\text{and} \\quad H_m = \\begin{bmatrix} H_{m/2} & H_{m/2} \\\\ H_{m/2} & -H_{m/2} \\end{bmatrix}.\n\nThe associated normalized Hadamard matrix is given by H^{(\\text{norm})}_m = \\frac{1}{\\sqrt{m}} H_m, which evidently satisfies H^{(\\text{norm})T}_m H^{(\\text{norm})}_m = I_{m \\times m}. Moreover, via a recursive algorithm, it is possible to compute matvec H_m x in time O(m \\log m), which is much faster than m^2 for a general matrix.\nTo solve the least squares minimization problem using conjugate gradients, we must solve A^T A x = A^T b. Using a preconditioner M such that M \\approx A^{-1} can give substantial speedup in computing solutions to large problems.\nConsider the following scheme to generate a randomized preconditioner, assuming that m = 2^i for some i:\n\nLet S = \\text{diag}(S_{11}, \\ldots, S_{mm}), where S_{jj} are random \\{-1,+1\\} signs\nLet p \\in \\mathbb{Z}^+ be a small positive integer, say 20 for this problem.\nLet R \\in \\{0, 1\\}^{n+p \\times m} be a row selection matrix, meaning that each row of R has only 1 non-zero entry, chosen uniformly at random. (The location of these non-zero columns is distinct.)\nimport jax.numpy as jnp\nfrom jax import random\n\ndef create_row_selection_matrix_jax(m, n, p, key):\n    # m is the number of columns in the original matrix A\n    # n+p is the number of rows in the row selection matrix R\n    # key is a PRNGKey needed for randomness in JAX\n    inds = random.permutation(key, m)[:n+p]  # Generate a random permutation and select the first n+p indices\n    R = jnp.zeros((n+p, m), dtype=jnp.int32)  # Create a zero matrix of shape (n+p, m)\n    R = R.at[np.arange(n+p), inds].set(1)     # Use JAX's indexed update to set the entries corresponding to inds to 1\n    return R\nDefine \\Phi = R H^{(\\text{norm})}_m S \\in \\mathbb{R}^{n+p \\times m}\n\nWe then define the matrix ( M ) via its inverse ( M^{-1} = A^T \\Phi^T \\Phi A \\in \\mathbb{R}^{n \\times n} ).\nQuestions\n\n(2 points) How many FLOPs (floating point operations, i.e. multiplication and additions) are required to compute the matrices M^{-1} and M, respectively, assuming that you can compute the matrix-vector product H_mv in time m \\log m for any vector v \\in \\mathbb{R}^m?\n(2 points) How many FLOPs are required to naively compute A^T A, assuming A is dense (using standard matrix algorithms)?\n(2 points) How many FLOPs are required to compute A^T A v for a vector v \\in \\mathbb{R}^n by first computing u = Av and then computing A^T u?\n(4 points) Suppose that conjugate gradients runs for k iterations. Using the preconditioned conjugate gradient algorithm with M = (A^T \\Phi^T \\Phi A)^{-1}, how many total floating point operations have been performed? How many would be required to directly solve A^T A x = A^T b? How large must k be to make the conjugate gradient method slower?\n(10 points) Implement the conjugate gradient algorithm for solving the positive definite linear system A^T A x = A^T b both with and without the preconditioner M. To generate data for your problem, set m = 2^{12} and n = 400, then generate the matrix A and the vector b. For simplicity in implementation, you may directly pass A^T A and A^T b into your conjugate gradient solver, as we only wish to explore how the methods work.\n\nimport numpy as np\nfrom scipy.sparse import diags\n\nm = 2**12  # 4096\nn = 400\n# Create a linear space of values from 0.001 to 100\nvalues = np.linspace(0.001, 100, n)\n# Generate the matrix A\nA = np.random.randn(m, n) * diags(values).toarray()\nb = np.random.randn(m, 1)\nPlot the norm of the residual r_k = A^T b - A^T A x_k (relative to \\|A^T b\\|_2) as a function of iteration k for each of your conjugate gradient procedures. Additionally, compute and print the condition numbers \\kappa(A^T A) and \\kappa(M^{1/2} A^T A M^{1/2}).\n\n\n\nGradient methods for conditional problems\n\n🐺 Frank - Wolfe vs Projected gradient descent [20 points]\nConsider the following simple quadratic optimization problem\n\nf(w) = \\frac12 \\langle Ax, x \\rangle - \\langle b, x \\rangle \\to \\min\\limits_{x \\in \\mathbb{R}^n; \\; 1^\\top x = 1, \\; x \\succeq 0}\n\n\nGenerate and solve this problem numerically with CVXPY. Calculate optimal solution x_optimal\nimport jax\nfrom jax import numpy as jnp\nfrom jax import random\nfrom jax import grad\n\ndef generate_problem(n, mu=0, L = 10):\n    RNG = random.PRNGKey(0)\n\n    U = random.normal(RNG, (n, n))\n    Q, _ = jnp.linalg.qr(U)\n    Lambda = jnp.diag(jnp.linspace(mu, L, n, endpoint=True))\n    A = Q @ Lambda @ Q.T\n\n    RNG, _ = random.split(RNG)\n    b = random.normal(RNG, (n, 1))\n\n    def f(x, A=A, b=b):\n        return 1/2 * x.T @ A @ x - b.T @ x\n\n    grad_f = grad(f)\n\n    RNG, _ = random.split(RNG)\n    x_0 = jnp.zeros(n)\n    idx = random.randint(RNG, (1,), 0, n)\n    x_0 = x_0.at[idx].set(1.0)\n\n    return f, grad_f, A, b, x_0\n\ndef compute optimal(A, b):\n    ### ======\n    ### YOUR CODE HERE\n    ### ======\n    return x_optimal\nIn this problem you will consider 2 algorithms for solving this problem (Frank - Wolfe and Projected Gradient Descent). Let’s start with PGD. Write down the function, that calculates Euclidian projection on the simplex:\ndef projection(y):\n    ### ======\n    ### YOUR CODE HERE\n    ### ======\n    return x\nThen, write the PGD method, that returns a trajectory list of iterations+1 points x_0, x_1, \\ldots x_k and time_trajectory list for a cumulative time spent after each iteration :\ndef PGD(A, b, x_0, iterations):\n    return trajectory, time_trajectory\nWrite down the FW method, that returns a trajectory list of iterations+1 points x_0, x_1, \\ldots x_k and time_trajectory list for a cumulative time spent after each iteration :\ndef FW(A, b, x_0, iterations):\n    return trajectory, time_trajectory\nGenerate a convex problem (\\mu=0, L=10) and compare the methods starting from the same x_0. For this reason plot 2 graphs - f(x_k) - f^* from iteration counter and time spent for it.\nGenerate a strongly convex problem (\\mu=1, L=10) and compare the methods starting from the same x_0. For this reason plot 2 graphs - f(x_k) - f^* from iteration counter and time spent for it."
  },
  {
    "objectID": "files/mds.html",
    "href": "files/mds.html",
    "title": "",
    "section": "",
    "text": "!pip install -q geopy\n\n\n[notice] A new release of pip is available: 23.2.1 -&gt; 23.3.2\n[notice] To update, run: python3.9 -m pip install --upgrade pip\n\n\n\nimport numpy as np\nfrom geopy.distance import geodesic\n\n# Estimated GPS coordinates for the specified Moscow Metro stations\n# Format: \"Station Name\": (Latitude, Longitude)\nstations_coordinates = {\n    \"Fizteh\": (55.5518, 37.3247),           # Estimated coordinates for Fizteh\n    \"Chkalovskaya\": (55.4523, 37.3926),\n    \"Slavyanski Boulevard\": (55.4347, 37.2814),\n    \"Park Kultury\": (55.4409, 37.3529),\n    \"Komsomolskaya\": (55.4629, 37.3918),\n    \"Yugo-Zapadnaya\": (55.3949, 37.2900),\n    \"Kievskaya\": (55.4440, 37.3356),\n    \"Strogino\": (55.4814, 37.2411),\n    \"Konkovo\": (55.3800, 37.3108),\n    \"VDNKh\": (55.4916, 37.3828),\n    \"Tekstilshiki\": (55.4232, 37.4354)\n}\n\n# Calculate the pairwise distance matrix\ndef calculate_distance_matrix(coords_dict):\n    station_names = list(coords_dict.keys())\n    n_stations = len(station_names)\n    distance_matrix = np.zeros((n_stations, n_stations))\n\n    for i in range(n_stations):\n        for j in range(n_stations):\n            if i != j:\n                distance_matrix[i][j] = geodesic(coords_dict[station_names[i]], coords_dict[station_names[j]]).kilometers\n            else:\n                distance_matrix[i][j] = 0\n\n    return station_names, distance_matrix\n\nstation_names, distance_matrix = calculate_distance_matrix(stations_coordinates)\ndistance_matrix, station_names\n\n\n(array([[ 0.        , 11.8795683 , 13.32121955, 12.47476534, 10.76730899,\n         17.60531703, 12.02141556,  9.45093857, 19.14704757,  7.64111262,\n         15.93607716],\n        [11.8795683 ,  0.        ,  7.30513134,  2.81466242,  1.18120326,\n          9.11269391,  3.72338261, 10.11508331,  9.57219188,  4.41903113,\n          4.22314047],\n        [13.32121955,  7.30513134,  0.        ,  4.57796148,  7.6589319 ,\n          4.46432896,  3.58332329,  5.79065187,  6.36819994,  9.01496207,\n          9.83338314],\n        [12.47476534,  2.81466242,  4.57796148,  0.        ,  3.47233987,\n          6.48795948,  1.14799012,  8.3873321 ,  7.28559471,  5.95292621,\n          5.58202776],\n        [10.76730899,  1.18120326,  7.6589319 ,  3.47233987,  0.        ,\n          9.94233619,  4.13173454,  9.75035755, 10.55879981,  3.24552038,\n          5.21047455],\n        [17.60531703,  9.11269391,  4.46432896,  6.48795948,  9.94233619,\n          0.        ,  6.18218626, 10.11534229,  2.11882318, 12.26352411,\n          9.73385562],\n        [12.02141556,  3.72338261,  3.58332329,  1.14799012,  4.13173454,\n          6.18218626,  0.        ,  7.28489644,  7.29627254,  6.08240265,\n          6.72859259],\n        [ 9.45093857, 10.11508331,  5.79065187,  8.3873321 ,  9.75035755,\n         10.11534229,  7.28489644,  0.        , 12.12071314,  9.02961058,\n         13.89681105],\n        [19.14704757,  9.57219188,  6.36819994,  7.28559471, 10.55879981,\n          2.11882318,  7.29627254, 12.12071314,  0.        , 13.23410172,\n          9.24357874],\n        [ 7.64111262,  4.41903113,  9.01496207,  5.95292621,  3.24552038,\n         12.26352411,  6.08240265,  9.02961058, 13.23410172,  0.        ,\n          8.31043471],\n        [15.93607716,  4.22314047,  9.83338314,  5.58202776,  5.21047455,\n          9.73385562,  6.72859259, 13.89681105,  9.24357874,  8.31043471,\n          0.        ]]),\n ['Fizteh',\n  'Chkalovskaya',\n  'Slavyanski Boulevard',\n  'Park Kultury',\n  'Komsomolskaya',\n  'Yugo-Zapadnaya',\n  'Kievskaya',\n  'Strogino',\n  'Konkovo',\n  'VDNKh',\n  'Tekstilshiki'])\n\n\n\nimport matplotlib.pyplot as plt\n\ndef gradient_descent_mds(D, dimensions=2, learning_rate=0.01, iterations=1000):\n    \"\"\"\n    Perform Multidimensional Scaling using Gradient Descent.\n\n    :param D: NxN distance matrix.\n    :param dimensions: Number of dimensions for the output coordinates.\n    :param learning_rate: Learning rate for gradient descent.\n    :param iterations: Number of iterations.\n    :return: Nx2 matrix of coordinates.\n    \"\"\"\n    N = D.shape[0]\n    # Random initialization of coordinates\n    X = np.random.rand(N, dimensions)\n\n    for iteration in range(iterations):\n        # Compute distance matrix for current coordinates\n        D_hat = np.sqrt(np.sum((X[:, np.newaxis, :] - X[np.newaxis, :, :]) ** 2, axis=2))\n\n        # Compute gradient\n        delta = D_hat - D\n        for i in range(N):\n            for j in range(N):\n                if i != j:\n                    grad = (delta[i, j] / D_hat[i, j]) * (X[i, :] - X[j, :])\n                    X[i, :] -= learning_rate * grad\n\n    return X\n\n# Perform MDS\ncoordinates_mds = gradient_descent_mds(distance_matrix)\n\n# Plotting the results\nplt.figure(figsize=(10, 8))\nplt.scatter(coordinates_mds[:, 0], coordinates_mds[:, 1])\nfor i, name in enumerate(station_names):\n    plt.annotate(name, (coordinates_mds[i, 0], coordinates_mds[i, 1]))\nplt.title(\"2D Representation of Moscow Metro Stations using MDS\")\nplt.xlabel(\"X Coordinate\")\nplt.ylabel(\"Y Coordinate\")\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom geopy.distance import geodesic\n\n# Estimated GPS coordinates for the specified Moscow Metro stations\nstations_coordinates = {\n    \"Fizteh\": (55.5518, 37.3247),\n    \"Chkalovskaya\": (55.4523, 37.3926),\n    \"Slavyanski Boulevard\": (55.4347, 37.2814),\n    \"Park Kultury\": (55.4409, 37.3529),\n    \"Komsomolskaya\": (55.4629, 37.3918),\n    \"Yugo-Zapadnaya\": (55.3949, 37.2900),\n    \"Kievskaya\": (55.4440, 37.3356),\n    \"Strogino\": (55.4814, 37.2411),\n    \"Konkovo\": (55.3800, 37.3108),\n    \"VDNKh\": (55.4916, 37.3828),\n    \"Tekstilshiki\": (55.4232, 37.4354)\n}\n\n# Calculate the pairwise distance matrix\ndef calculate_distance_matrix(coords_dict):\n    station_names = list(coords_dict.keys())\n    n_stations = len(station_names)\n    distance_matrix = np.zeros((n_stations, n_stations))\n\n    for i in range(n_stations):\n        for j in range(n_stations):\n            if i != j:\n                distance_matrix[i][j] = geodesic(coords_dict[station_names[i]], coords_dict[station_names[j]]).kilometers\n            else:\n                distance_matrix[i][j] = 0\n\n    return station_names, distance_matrix\n\nstation_names, distance_matrix = calculate_distance_matrix(stations_coordinates)\n\n# Gradient Descent MDS with data collection for animation\ndef gradient_descent_mds(D, dimensions=2, learning_rate=0.01, iterations=1000):\n    N = D.shape[0]\n    X = np.random.rand(N, dimensions)\n\n    # Records for animation\n    positions_record = []\n    loss_record = []\n\n    for iteration in range(iterations):\n        D_hat = np.sqrt(np.sum((X[:, np.newaxis, :] - X[np.newaxis, :, :]) ** 2, axis=2))\n        delta = D_hat - D\n        loss = np.sum(delta**2)  # Loss calculation\n        positions_record.append(X.copy())\n        loss_record.append(loss)\n\n        # Gradient descent update\n        for i in range(N):\n            for j in range(N):\n                if i != j:\n                    grad = (delta[i, j] / D_hat[i, j]) * (X[i, :] - X[j, :])\n                    X[i, :] -= learning_rate * grad\n\n    return positions_record, loss_record\n\n# Perform MDS and collect data for animation\npositions_record, loss_record = gradient_descent_mds(distance_matrix, iterations=100)\n\n# Function to update each frame in the animation\ndef update_frame(num, positions_record, loss_record, station_names, scat, line, ax1, ax2):\n    # Clear previous station labels and tails\n    ax1.clear()\n    ax1.set_xlim(-10, 10)\n    ax1.set_ylim(-10, 10)\n    ax1.set_title('Station Positions')\n    ax1.set_xlabel('X Coordinate')\n    ax1.set_ylabel('Y Coordinate')\n\n    # Update station positions and draw tails\n    scat.set_offsets(positions_record[num])\n    for i, name in enumerate(station_names):\n        # Draw the tail for each station\n        if num &gt; 0:\n            for past in range(num):\n                ax1.plot([positions_record[past][i, 0], positions_record[past+1][i, 0]],\n                         [positions_record[past][i, 1], positions_record[past+1][i, 1]],\n                         color='gray', alpha=0.5)\n\n        # Label the final position of the station\n        if num == len(positions_record) - 1:\n            ax1.text(positions_record[num][i, 0], positions_record[num][i, 1], name, fontsize=8)\n\n    # Update loss evolution plot\n    line.set_data(range(num + 1), loss_record[:num + 1])\n    ax2.set_xlim(0, 100)\n    ax2.set_ylim(min(loss_record), max(loss_record))\n    ax2.set_title('Loss Evolution')\n    ax2.set_xlabel('Iteration')\n    ax2.set_ylabel('Loss')\n\n    return scat, line\n\n# Create the figure for animation\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))\n\n# Scatter plot for station positions\nscat = ax1.scatter([], [], s=30)\nax1.set_xlim(-10, 10)\nax1.set_ylim(-10, 10)\nax1.set_title('Station Positions')\nax1.set_xlabel('X Coordinate')\nax1.set_ylabel('Y Coordinate')\n\n# Line plot for loss evolution\nline, = ax2.semilogy([], [], lw=2)\nax2.set_xlim(0, 100)\nax2.set_ylim(min(loss_record), max(loss_record))\nax2.set_title('Loss Evolution')\nax2.set_xlabel('Iteration')\nax2.set_ylabel('Loss')\n\n# Creating the animation\nani = animation.FuncAnimation(fig, update_frame, frames=100, fargs=(positions_record, loss_record, station_names, scat, line, ax1, ax2), blit=False, repeat=False)\n\n# Saving the animation\nani.save('moscow_metro_mds_animation.mp4', writer='ffmpeg', fps=10)\n\n\n\n\n\n\n\n\n\npositions_record[-1]\n\narray([[ 8.02981262,  8.63001461],\n       [ 2.25518938, -2.67734712],\n       [-3.33834951,  1.74376926],\n       [-0.07801013, -1.44497825],\n       [ 3.09715112, -2.01602395],\n       [-6.46246911, -1.07594008],\n       [-0.48882653, -0.35399986],\n       [-1.32473107,  7.16441546],\n       [-6.86842661, -3.2663034 ],\n       [ 5.7281098 ,  1.15859194],\n       [ 4.50067386, -4.182293  ]])\n\n\n\nnp.max()\n\n100"
  },
  {
    "objectID": "program.html",
    "href": "program.html",
    "title": "",
    "section": "",
    "text": "Class 1\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar • ▶️ Youtube • 💿 Download\n    \n    Вспоминаем линейную алгебру. Некоторые матричные разложения. Скорость сходимости.\n\n    Class 2\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar • ▶️ Youtube • 💿 Download\n    \n    Одномерная оптимизация. Неточная одномерная оптимизация. Градиент. Гессиан. Матрично-векторное дифференцирование.\n\n    Class 3\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar • ▶️ Youtube • 💿 Download\n    \n    Автоматическое дифференцирование. Вычислительный граф.\n\n    Class 4\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar • ▶️ Youtube • 💿 Download\n    \n    Выпуклость. Выпуклые множества. Выпуклые функции. Неравенство Йенсена.\n\n    Class 5\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar • ▶️ Youtube • 💿 Download\n    \n    Сильно выпуклые функции. Условие Поляка - Лоясиевича. Линейная регрессия. Регуляризация. Выпуклость нейронных сетей.\n\n    Class 6\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar • ▶️ Youtube • 💿 Download\n    \n    Условия оптимальности. Функция Лагранжа. Задачи с ограничениями-равенствами. Задачи с ограничениями-равенствами. Теорема Каруша - Куна - Таккера.\n\n    Class 7\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar • ▶️ Youtube • 💿 Download\n    \n    Двойственность.\n\n    Class 8\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar • ▶️ Youtube • 💿 Download\n    \n    Задача линейного программирования. Симплекс метод.\n\n    Class 9\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar • ▶️ Youtube • 💿 Download\n    \n    Градиентный спуск. Теоремы сходимости в гладком случае (выпуклые, сильно выпуклые, PL). Верхние и нижние оценки сходимости.\n\n    Class 10\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar • ▶️ Youtube • 💿 Download\n    \n    Ускоренные градиентные методы. Метод Поляка, Нестерова.\n\n    Class 11\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar • ▶️ Youtube • 💿 Download\n    \n    Субградиент. Субдифференциал. Субградиентный спуск. Теоремы сходимости в негладком случае. Особенности работы градиентного метода в практических негладких задачах.\n\n    Class 12\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar • ▶️ Youtube • 💿 Download\n    \n    Метод сопряженных градиентов.\n\n    Class 13\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar • ▶️ Youtube • 💿 Download\n    \n    Градиентные методы в условных задачах оптимизации - метод проекции градиента. Метод Франк - Вульфа. Идея метода зеркального спуска.\n\n    Class 14\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar • ▶️ Youtube • 💿 Download\n    \n    Проксимальный градиентный метод.\n\n    Class 15\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar • ▶️ Youtube • 💿 Download\n    \n    Метод Ньютона. Квазиньютоновские методы.\n\n    Class 16\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar • ▶️ Youtube • 💿 Download\n    \n    Стохастический градиентный спуск.\n\n    Class 17\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar\n    \n    Методы редукции дисперсии: SAG, SVRG, SAGA. Адаптивные стохастические градиентные методы.\n\n    Class 18\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar\n    \n    Обучение нейронных сетей с точки зрения методов оптимизации. Обобщающая способность моделей машинного обучения. Double Descent. Grokking. Mode connectivity.\n\n    Class 19\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar\n    \n    Вопросы обучения больших моделей. Lars, Lamb. Learning rate schedulers. Warm-up. Клиппинг.\n\n    Class 20\n    \n        📄 Materials • 📝 Notes • 👷‍♂️ Seminar\n    \n    Введение в двойственные методы оптимизации. Метод двойственного градиентного подъёма. Метод модифицированной функции Лагранжа. ADMM.\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Optimization for ML",
    "section": "",
    "text": "Optimization for ML\n\nCourse for 3rd year students of CS department at HSE university. 1 lecture + 1 seminar per week.\nThe course covers convex, non-convex, continuous optimization topics, especially motivated by problems and applications in Machine Learning. Various topics are covered, from fundamental materials to recent research.\nDescription of the course.\n\n\nloss_surface.html\n\n\n\nTeam\n\n\n    \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      Daniil Merkulov\n                    \n                    Instructor\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      Farukh Yaushev\n                    \n                    Seminarist\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      Kirill Nikorov\n                    \n                    Seminarist\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      Michael Persiianov\n                    \n                    Seminarist\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      Arina Kosovskaia\n                    \n                    Senior Assistant\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      Daniil Radushev\n                    \n                    Assistant\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      Maria Medvedeva\n                    \n                    Assistant\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      Alina Potemkina\n                    \n                    Assistant\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      Oleg Kurilov\n                    \n                    Assistant\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      Sabina Akilova\n                    \n                    Assistant\n                  \n                \n              \n        \n            \n                \n                  \n                    \n                  \n                  \n                    \n                      Svetlana Mikhailova\n                    \n                    Assistant\n                  \n                \n              \n        \n    \n\n\nNo matching items"
  }
]